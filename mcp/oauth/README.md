# Dubbo-go-pixiu MCP OAuth Authorization Example

English | [中文](./README_zh.md)

## Overview

This example demonstrates how to integrate OAuth2 authorization in Pixiu Gateway to protect MCP (Model Context Protocol) endpoints. It implements a complete OAuth2 Authorization Code flow with PKCE, showcasing a three-tier architecture integration:

- **Authorization Server** (localhost:9000) - Provides OAuth2 authorization services with PKCE support
- **Resource Server** (Pixiu Gateway, localhost:8888) - Protects MCP endpoint `/mcp`
- **Backend API Server** (localhost:8081) - Provides actual business APIs

## Architecture Diagram

```
Client → Authorization Server (OAuth2) → Pixiu Gateway (MCP) → Backend API
        ↑                                  ↑                    ↑
   Get Access Token                   JWT Validation/MCP      Actual API Calls
```

## Quick Start

### 1. Start Backend API Server

```bash
cd mcp/simple/server
go run server.go
# Service will start at http://localhost:8081
```

### 2. Start OAuth2 Authorization Server

```bash
cd tools/authserver
go run *.go
# Authorization server will start at http://localhost:9000
```

### 3. Start Pixiu Gateway

```bash
# Execute in dubbo-go-pixiu project root directory
go run cmd/pixiu/*.go gateway start -c /path/to/dubbo-go-pixiu-samples/mcp/oauth/pixiu/conf.yaml
# Gateway will start at http://localhost:8888, protecting /mcp endpoint
```

### 4. Verify Service Status

```bash
# Check authorization server
curl http://localhost:9000/.well-known/oauth-authorization-server

# Check backend API (no authorization required)
curl http://localhost:8081/api/health

# Check Pixiu MCP endpoint (should return 401 Unauthorized)
curl http://localhost:8888/mcp
```

## OAuth2 Authorization Flow Testing

### Method 1: Run Automated Tests

```bash
cd test
go test -v
```

The tests will automatically execute:
- Generate PKCE parameters
- Obtain authorization code
- Exchange for access token
- Call protected MCP endpoints

### Method 2: Manual Testing (Simulating Authorization Code Flow)

Since the authorization server auto-approves requests in demo mode, you can manually simulate the complete flow:

```bash
# 1. Generate PKCE parameters (generated by client in real applications)
CODE_VERIFIER=$(head -c 32 /dev/urandom | base64 | tr -d "=+/" | cut -c1-43)
CODE_CHALLENGE=$(echo -n $CODE_VERIFIER | shasum -a 256 | cut -d' ' -f1 | xxd -r -p | base64 | tr -d "=+/")

# 2. Get authorization code (simulate browser redirect, auth server auto-approves)
AUTH_URL="http://localhost:9000/oauth/authorize?client_id=sample-client&redirect_uri=http://localhost:8081/callback&response_type=code&code_challenge=$CODE_CHALLENGE&code_challenge_method=S256&resource=http://localhost:8888/mcp"

# Visit authorization URL and extract code from redirect (manual operation required)
echo "Please visit: $AUTH_URL"
echo "Extract the 'code' parameter from the redirect URL, then proceed to next step"

# 3. Exchange authorization code for access token
read -p "Please enter authorization code: " AUTH_CODE
TOKEN=$(curl -s -X POST http://localhost:9000/oauth/token \
  -d "grant_type=authorization_code" \
  -d "code=$AUTH_CODE" \
  -d "client_id=sample-client" \
  -d "redirect_uri=http://localhost:8081/callback" \
  -d "code_verifier=$CODE_VERIFIER" \
  -d "resource=http://localhost:8888/mcp" | jq -r .access_token)

echo "Obtained access token: $TOKEN"
```

### Method 3: Using Access Token to Call MCP APIs

```bash
# Get tools list
curl -s -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' \
  http://localhost:8888/mcp | jq

# Call health check tool
curl -s -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"tools/call","params":{"name":"health_check","arguments":{}}}' \
  http://localhost:8888/mcp | jq

# Call user query tool
curl -s -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"tools/call","params":{"name":"get_user","arguments":{"id":1,"include_profile":true}}}' \
  http://localhost:8888/mcp | jq
```

## Configuration

### OAuth2 Configuration (pixiu/conf.yaml)

```yaml
# MCP Authorization Filter Configuration
- name: "dgp.filter.http.auth.mcp"
  config:
    resource_metadata:
      path: "/.well-known/oauth-protected-resource/mcp"
      resource: "http://localhost:8888/mcp"
      authorization_servers:
        - "http://localhost:9000"
    providers:
      - name: "local"
        issuer: "http://localhost:9000"
        jwks: "http://localhost:9000/.well-known/jwks.json"
    rules:
      - cluster: "mcp-protected"
```

### Key Features

- **PKCE Support**: Enhances security of authorization code flow
- **JWT Validation**: Uses remote JWKS for token signature verification
- **Fine-grained Protection**: Only protects `/mcp` endpoint, other endpoints pass through
- **MCP Integration**: Complete support for MCP JSON-RPC protocol

## Troubleshooting

### Common Issues

1. **401 Unauthorized Error**
   - Check if access token is correct
   - Confirm token has not expired
   - Verify `resource` parameter matches

2. **Service Not Available**
   - Ensure all three services are started
   - Check if ports are occupied
   - Review service logs for detailed errors

3. **JWT Verification Failed**
   - Confirm authorization server's JWKS endpoint is accessible
   - Check system time synchronization

### Log Viewing

```bash
# View Pixiu logs (JWT validation related)
tail -f pixiu.log

# View authorization server logs
# Check console output in authserver directory
```

## Extended Usage

### Adding New MCP Tools

Add new tool definitions in the `tools` section of `pixiu/conf.yaml`:

```yaml
- name: "custom_tool"
  description: "Custom tool description"
  cluster: "mock-server"
  request:
    method: "GET"
    path: "/api/custom"
    timeout: "10s"
```

## Security Considerations

⚠️ **Important**: This example is for development and demonstration purposes only. Production environments require additional considerations:

- Use HTTPS to protect all communications
- Implement real user authentication and authorization
- Use secure key management
- Add request rate limiting and monitoring
- Implement token refresh mechanisms
